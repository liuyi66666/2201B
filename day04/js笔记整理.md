# 获取dom节点的方法
 原生JS获取DOM元素的六种方法:
        document.getElementsByClassName 根据CSS类名获取DOM元素
        document.getElementsByTagName 根据标签名获取DOM元素
        document.getElementById() 根据ID名获取DOM元素
        document.querySelector() 里面跟CSS选择器一样的写法，选择的是第一个满足条件的元素
        document.querySelectorAll() 选择的是满足条件的所有元素，可以根据下标精准选择
        document.getElementsByName 根据name属性获取DOM元素（一般用于表单元素，不常用）
# 伪数组和数组的区别：
1、数组的长度是可变的，是内置的属性，伪数组的长度不可变，是自定义的一个属性
2、数组可以使用数组中的方法，伪数组不可以使用数组中的方法
3、数组可以访问数组中的方法 伪数组不能直接访问数组的方法
4、伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
# arguments 
1）js中每个函数都会有一个Arguments对象实例arguments引用着函数的实参，可以用数组下标的方式。
arguments.callee与形参--映射
特点：
1、arguments对象和Function是分不开的。
2、因为arguments这个对象不能显式创建。
3、arguments对象只有函数开始时才可用。
arguments 对象不是一个数组 但是访问单个参数的方式与访问数组元素的方式相同

# 事件循环
1、js是一个单线程
2、单线程分两个任务：同步任务和异步任务，先执行同步任务，当异步任务出现的时候，会先将异步任务存放在任务队列中，当执行完所有的同步任务之后，再去调用任务队列中的异步任务，异步任务又分为宏任务和微任务，一般先执行微任务然后再执行宏任务。
3、宏任务：定时器、事件绑定、ajax等
   微任务：Promise的then、catch、finally和process的nextTick
# 深拷贝和浅拷贝
浅拷贝：浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。

深拷贝：深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。
深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝；

 ## 深拷贝的方法:
 1）递归（deepclone）
  //递归函数   使用递归函数实现对象的深拷贝
		function cloneObject(obj){
			// 临时对象  暂时存放属性 及属性值
			var newObj = {};
			// obj如果是基本数据类型  直接返回
			if (typeof(obj) !== "object") {
              return  obj
            }
			//如果是引用类型，遍历属性
             else{
                for(var attr in obj){
              //如果某个属性还是引用数据类型  递归调用
                newObj[attr] = cloneObject(obj[attr])
                                    }
                }	
               return newObj;				
		}
 2） JSON.parse(JSON.stringify(obj))：缺点： ① 对象的属性值是函数时，无法拷贝
                                          ② 原型链上的属性无法拷贝
                                          ③ 不能正确的处理Data类型的数据
                                          ④ 不能处理RegExp
                                          ⑤ 会忽略symbol、undefined
 浅拷贝的方法：for in ，es6:Object.assign，es6:扩展运算符...,Array.prototype.slice(),Array.prototype.concat()
# let const 作用域（独立的地盘，让变量不会外泄，暴露出去，最大的作用就是隔离变量，不同作用域下同名变量不会有冲突）
作用域：全局作用域、函数作用域、块级作用域（es6新增）
 ## let 特点：
 1）变量不能重复声明（当前作用域不可以重复声明，在下一个作用域的时候可以重复声明）
 2）块级作用域
 3）不存在变量提升
 4）不影响作用域链
 ## const 特点：
             1）声明一个常量，且不可更改
              2）一般常量用大写
              3）块级作用域
              4）对于数组和对象的元素修改，不算做对常量的修改，不会报错（因为只修改了内容，没有修改指针）
               5）声明复杂数据类型，值可以更改，因为堆和栈，复杂数据类型只是修改了堆中间的内容，栈的引用没有变
# 解构赋值
概念：es6中按照一定模式从数组和对象中提取值，对变量进行赋值
1、数组的解构：
  1）以下标来进行解构，有序解构，不能单独解构出一个值
2、对象的解构：
   1）以属性名来进行解构，可以单独解构任何一个属性

# 模板字符串  对象的简化
模板字符串：ES6引入了一种新型的字符串字面量语法，我们称之为模板字符串（template strings）。除了使用反撇号字符 ` 代替普通字符串的引号 ' 或 " 外，它们看起来与普通字符串并无二致。
# 箭头函数 
 es6 允许使用()=>定义函数
 ## 特点：
  1）this是动态的，this的值取决于函数本身如何被调用
  2）没有arguments伪数组，如果有绝对是来自于父组件
  3）不能作为构造实例化对象
# Symbol  promis
## symbol：
symbol的值是唯一的，用来解决命名冲突问题
       2）symbol的值不能和其他数据进行运算
       3）symbol定义的对象属性不能使用for...in循环遍历，但是可以使用Rellect.ownkeys来获取对象的所有键名
## 函数参数（es6允许给函数参数赋值初始值） rest参数
1）实参：调用函数实际传的参数
2）形参（初始值具有默认值的参数，一般位置靠后）：比如：a、b
 3）rest参数，用于获取函数的实参，用来代替arguments

## promise函数
1）概念：promise函数是解决异步编程问题产生的，promise简单说就是一个容器，里面保存着某个未来才会结束的事件
promise语法上是一个对象，从它可以获取异步操作的消息。promise提供统一的API，各种异步操作都可以用同样的方法进行处理
2）promse可以解决的问题：
promise 是 es6 提供的一种异步解决方案，promise 可以解决回调地问题
回调地狱就是拿到 a 接口的数据后才能根据 a 返回的数据请求 b 接口这样回调函数嵌套回调函数的写法就叫回调地狱
这种写法会让代码臃肿 并且后期难以维护除了 promise 之外 async 是解决回调地狱的最终方案
3）特点：
promise ⼀共有三个状态,分别是进⾏中（pending）,成功（rejected）或者失败（fulfilled） 如果成功的话可以通过 resolve ⽅法将正确结
果返回出去,通过.then 的⽅式进⾏接受,失败的话可以通过 reject 的⽅式将失败的结果返回出去,通 过.catch 的⽅式进⾏接受,pending 状态是进⾏中,⼀旦进⾏之后,他的状态是不可逆的






























伪数组和数组的区别
    伪数组
        伪数组就是不是真实的数组，无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以像遍历数组那样来遍历它们，所以叫伪数组。
        特点
            必须要有length属性
            如果length属性值为0，那么这个对象有没有元素（key为0,1,2的元素）无所谓
            如果length属性值不为0，那么这个对象一定有"下标"为length-1的元素


    数组
        可以看到普通数组的_proto_有非常多的方法

    区别
        伪数组与数组的区别就是它们的_proto_区别，
        普通数组有很多数组的方法，比如说push，shift，map等等
        而伪数组却没有，所以我们称这类解构类似数组却没有数组方法的集合叫做伪数组。


伪数组怎样转化为数组
    最简单的，先准备一个新的空数组，然后遍历伪数组，将伪数组中的值通过索引逐个添加到新数组当中。
    利用扩展运算符(...)将伪数组转化为真数组 - ES6语法
    利用Array的原型对象的slice方法，配合call()方法修改slice中this指向
    利用Array.from方法 - ES6