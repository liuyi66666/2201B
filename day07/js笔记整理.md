# 获取dom节点的方法
 原生JS获取DOM元素的六种方法:
        document.getElementsByClassName 根据CSS类名获取DOM元素
        document.getElementsByTagName 根据标签名获取DOM元素
        document.getElementById() 根据ID名获取DOM元素
        document.querySelector() 里面跟CSS选择器一样的写法，选择的是第一个满足条件的元素
        document.querySelectorAll() 选择的是满足条件的所有元素，可以根据下标精准选择
        document.getElementsByName 根据name属性获取DOM元素（一般用于表单元素，不常用）
# 伪数组和数组的区别：
1、数组的长度是可变的，是内置的属性，伪数组的长度不可变，是自定义的一个属性
2、数组可以使用数组中的方法，伪数组不可以使用数组中的方法
3、数组可以访问数组中的方法 伪数组不能直接访问数组的方法
4、伪数组的索引，就是那些键值对的key，没有真正的顺序可言；长度是手动设置的
# arguments 
1）js中每个函数都会有一个Arguments对象实例arguments引用着函数的实参，可以用数组下标的方式。
arguments.callee与形参--映射
特点：
1、arguments对象和Function是分不开的。
2、因为arguments这个对象不能显式创建。
3、arguments对象只有函数开始时才可用。
arguments 对象不是一个数组 但是访问单个参数的方式与访问数组元素的方式相同

# 事件循环
1、js是一个单线程，即同一时间执行一个任务。
2、单线程分两个任务：同步任务和异步任务，先执行同步任务，当异步任务出现的时候，会先将异步任务存放在任务队列中，当执行完所有的同步任务之后，再去调用任务队列中的异步任务，异步任务又分为宏任务和微任务，一般先执行微任务然后再执行宏任务。
3、宏任务：定时器、事件绑定、ajax等
   微任务：Promise的then、catch、finally和process的nextTick
# 深拷贝和浅拷贝
浅拷贝：浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。

深拷贝：深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。
深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝；

 ## 深拷贝的方法:
 1）递归（deepclone）
  //递归函数   使用递归函数实现对象的深拷贝
		function cloneObject(obj){
			// 临时对象  暂时存放属性 及属性值
			var newObj = {};
			// obj如果是基本数据类型  直接返回
			if (typeof(obj) !== "object") {
              return  obj
            }
			//如果是引用类型，遍历属性
             else{
                for(var attr in obj){
              //如果某个属性还是引用数据类型  递归调用
                newObj[attr] = cloneObject(obj[attr])
                                    }
                }	
               return newObj;				
		}
 2） JSON.parse(JSON.stringify(obj))：缺点： ① 对象的属性值是函数时，无法拷贝
                                          ② 原型链上的属性无法拷贝
                                          ③ 不能正确的处理Data类型的数据
                                          ④ 不能处理RegExp
                                          ⑤ 会忽略symbol、undefined
 浅拷贝的方法：for in ，es6:Object.assign，es6:扩展运算符...,Array.prototype.slice(),Array.prototype.concat()
# let const 块级作用域（独立的地盘，让变量不会外泄，暴露出去，最大的作用就是隔离变量，不同作用域下同名变量不会有冲突）
作用域：全局作用域、函数作用域、块级作用域（es6新增）
 ## let 特点：
 1）变量不能重复声明（当前作用域不可以重复声明，在下一个作用域的时候可以重复声明）
 2）块级作用域
 3）不存在变量提升
 4）不影响作用域链
 ## const 特点：
             1）声明一个常量，且不可更改
              2）一般常量用大写
              3）块级作用域
              4）对于数组和对象的元素修改，不算做对常量的修改，不会报错（因为只修改了内容，没有修改指针）
               5）声明复杂数据类型，值可以更改，因为堆和栈，复杂数据类型只是修改了堆中间的内容，栈的引用没有变
# 解构赋值
概念：es6中按照一定模式从数组和对象中提取值，对变量进行赋值
1、数组的解构：
  1）以下标来进行解构，有序解构，不能单独解构出一个值
2、对象的解构：
   1）以属性名来进行解构，可以单独解构任何一个属性

# 模板字符串  对象的简化
模板字符串：ES6引入了一种新型的字符串字面量语法，我们称之为模板字符串（template strings）。除了使用反撇号字符 ` 代替普通字符串的引号 ' 或 " 外，它们看起来与普通字符串并无二致。
# 箭头函数 
 es6 允许使用()=>定义函数
 ## 特点：
  1）this是动态的，this的值取决于函数本身如何被调用
  2）没有arguments伪数组，如果有绝对是来自于父组件
  3）不能作为构造实例化对象
# Symbol  promis
## symbol：
symbol的值是唯一的，用来解决命名冲突问题
       2）symbol的值不能和其他数据进行运算
       3）symbol定义的对0象属性不能使用for...in循环遍历，但是可以使用Rellect.ownkeys来获取对象的所有键名
## 函数参数（es6允许给函数参数赋值初始值） rest参数
1）实参：调用函数实际传的参数
2）形参（初始值具有默认值的参数，一般位置靠后）：比如：a、b
 3）rest参数，用于获取函数的实参，用来代替arguments

## promise函数
1）概念：promise函数是解决异步编程问题产生的，promise简单说就是一个容器，里面保存着某个未来才会结束的事件
promise语法上是一个对象，从它可以获取异步操作的消息。promise提供统一的API，各种异步操作都可以用同样的方法进行处理
2）promse可以解决的问题：
promise 是 es6 提供的一种异步解决方案，promise 可以解决回调地问题
回调地狱就是拿到 a 接口的数据后才能根据 a 返回的数据请求 b 接口这样回调函数嵌套回调函数的写法就叫回调地狱
这种写法会让代码臃肿 并且后期难以维护除了 promise 之外 async 是解决回调地狱的最终方案
3）特点：
promise ⼀共有三个状态,分别是进⾏中（pending）,成功（rejected）或者失败（fulfilled） 如果成功的话可以通过 resolve ⽅法将正确结
果返回出去,通过.then 的⽅式进⾏接受,失败的话可以通过 reject 的⽅式将失败的结果返回出去,通 过.catch 的⽅式进⾏接受,pending 状态是进⾏中,⼀旦进⾏之后,他的状态是不可逆的

4)promise出现的原因：
1、为了解决异步回调问题
2、为了解决信任问题（第三方回调函数是不是只执行一次，性能，和执行多次）
3、为了解决回调执行顺序问题
4、为了解决捕捉错误能力

5）和事件循环的区别：
事件循环一旦错过，不会再被监听到
promise状态凝固，永远都可以被监听到

6）promise的回调参数
resolve->成功回调
reject->失败的回调


# promise的方法：☆
1、then
2、catch
    1)在链式调用中，catch只能捕捉第一个then返回的错误信息
    2）在链式调用中，想要单独的捕捉每个then的错误信息，需要每个then去跟随catch来进行捕获
3、all
   1）语法：promise.all([p1,p2,p3]).then(res=>console.log(res))
   2)特点：
   接收参数为数组
   返回值为一个数组，进行获取最终的结果
   必须等待全部参数返回成功后，才会执行，不能单独获取任何函数的一个值
   3)缺点：任何一个函数崩掉都不能执行

4、race
1）语法：promise.race([p1,p2,p3]).then(res=>console.log(res))
特点：
接受的参数为数组[]
返回值为一个数组，进行获取最终的结果
谁先执行完，返回谁，状态就是谁

5、finally：无论成功或失败总会执行

<!-- 链式调用 -->


# async和await
1、概念：async:快速创建一个异步函数，且是基于promise函数封装

在js中可以通过async关键字来快速创建异步函数，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。async函数也是函数，平常我们怎么使用函数就怎么使用它，直接加括号调用就可以。*async函数返回的是一个promise对象* ，如果要获取到promise返回值，要用then方法

## 特点：
优点：它把异步请求变成同步执行的async放在最近函数外调用，返回promise对象
    1）方便级联调用：即调用一次发生的场景
    2）同步代码编写方式：promise使用then函数进行链式调用，一直点点，是一种从左向右的横向写法：async、await从上到下，顺序执行，就像写同步代码一样，更符合代码编写习惯
缺点：没有catch错误处理，需要用原生try.catch进行错误处理
调用异步函数时，可以直接在函数前使用await关键字来对其进行调用

# Map对象
概念：本质上是键值对的集合
map用法：
1、使用new Map()
2、判断长度:map.size
3、添加元素map.set
4、获取键值map.get
5、判断当前对象存不存在该属性：map.has
6、判断当前对象中的属性map.delet
7、清空该方法的所有成员map.clear

# set数组
概念：Es6提供了新的数据解构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值
本质：是一个构造函数
set的实例遍历操作：
Set.prototype.keys()  返回键名的遍历器
Set.prototype.values() 返回键值的遍历器
Set.prototype.entries() 返回键值对的遍历器
Set.prototype.forEach()使用回调函数遍历每个成员
方法：
获取元素的个数:array.size()
添加元素：array.add()
删除元素：array.delete()
检测是否存在这个值：array.has()
清空：array.clear()


# 原型及原型链：
原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。
原型：
隐式原型(__proto__)：隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype

显示原型（prototype）：显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象
原型链：
当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`
# 继承：
原型继承：
优点：通过原型继承多个引用类型的属性和方法
缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题
盗用构造函数：
优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染
缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法
组合继承（原型继承+盗用构造函数继承）：
优点：集合了【原型继承】和【盗用构造函数继承】的优点
缺点：存在效率问题，Super始终会被调用两次
原型式继承：
优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性
缺点：无法判断实例的构造函数是父类还是子类

寄生式继承（构造函数模式+工厂模式）：
优点：根据一个对象克隆创建另一个对象，并增强对象
缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍
注意：objectCopy不是原生接口，是自定义方法，对入参对象进行复制

寄生式组合继承（盗用构造函数继承 + 原型式继承）



# class类
概念：Es6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板
作用：通过class关键字，可以定义类
有点：新的class写法只是让对象原型的写法更加清晰，更像面向编程的语法
Class get set
Class static
概念：类（class）通过static关键字定义静态方法
特点：不能在实例上调用静态方法，而是该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能
关键字：extends
关键方法：super（）//父类.call(this)


<!-- 类的继承 -->
<!-- 对象继承 -->
<!-- 类的静态成员 -->


# 数值的拓展
    1.Number.EPSILON表示最小精度
        数组的方法：Math.abs:取绝对值

    2.十进制1,2,3,0.2
    3.Number.isFinite 检测一个数值是否为有限数，小数和长度是有限的，无限叔表示是位数是无止尽的，例如圆周率
    4.Infinity无穷大
    5.Number,isNaN判断一个数值是不是NaN
    6.Number.isInteger 判断一个数是不是整数
    7.Number.parsetInt  Number.parseFloat
    8.Math.trunc将数字的小数部分抹掉
    9.Math.sign判断一个数到底为正数  负数  还是零  返回值不是true和false  而是  当为正数的时候返回1，负数的时候返回-1，0的时候返回0

# 数组的拓展
    扩展运算符
        含义：扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
        该运算符主要用于函数调用

    Array.from()
    Array.of()
    实例方法：copyWithin()
    实例方法：find()  findIndex()  findLast()  findLastIndex()
    实例方法：fill（）
    实例方法：entries()，keys()和values()
    实例方法：includes()
    实例方法：flat()  flatMap()
    实例方法：at（）
    实例方法：toReversed()  toSorted()   toSpliced()   with(index, value)
    实例方法：group()和groupToMap()
    数组的空位
    Array.prototype.sort()的排序

# 对象的拓展
    属性的简洁表示法
        ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。

    属性名表达式
        JavaScript 定义对象的属性，有两种方法。
            方法一是直接用标识符作为属性名
            方法二是用表达式作为属性名


    方法的name属性
        函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。

    属性的可枚举性和遍历
        可枚举性
            对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。

        属性的遍历
            for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
            Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
            Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
            Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。
            Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。


    super关键字
        我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。

    对象的扩展运算符
        已经介绍过扩展运算符（...）

    AggregateError错误对象
        为了配合新增的Promise.any()方法，还引入一个新的错误对象AggregateError

    Error对象的cause属性
        它的用法是new Error()生成 Error 实例时，给出一个描述对象，该对象可以设置cause属性。


# import|export的用法
    遵循规范
        ·require 是AMD 规范引入方式
        ·import是 ES6 的一个语法标准。如果要兼容浏览器的话必须转化成 ES5 的语法

    调用时间
        require是运行时调用，所以require理论上可以运用在代码的任何地方
        import是编译时调用，所以必须放在文件开头

    本质
        require 是赋值过程
        impot 是解构过程

    通过require引入基础数据类型时，属于赋值该变量。通过require引入复东数据类型时，属于浅拷贝该对象。

# proxy对象代理
    概念
        Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦裁和自定义(如属性查找、赋值、枚举、函数调用等)
    语法:
        const p = new Proxy(target, handler)target
    应用场景
        2.1 v3的reactive的双向绑定原理

